[{"title":"test1","date":"2021-11-04T09:17:36.000Z","url":"/2021/11/04/%E5%B9%B6%E6%9F%A5%E9%9B%86/","categories":[["undefined",""]],"content":"论文题目：并查集算法原理与实现 1 引言 过年了，你从大学回到家，客厅里早已坐满了人。由于你的家族人员过于庞大，要判断你和一个坐在客厅里的人是否是亲戚，确实还很不容易，所以为了拿到红包你要做足功课。通过调查，你知道了一系列的亲戚关系，比如 A 和 B 是亲戚， C 和 D 是亲戚等等……我们约定如果 A 和 B 是亲戚， B 和 C 是亲戚， 那么 C 和 D 是亲戚。现在你想知道客厅里的有谁与你有亲戚关系？ 这其实是一个很有现实意义的问题。我们可以建立模型，把所有人划分到若干个不相交的集合中，每个集合里的人彼此是亲戚。为了判断两个人是否为亲戚，只需看它们是否属于同一个集合即可。 而这个就是所谓的并查集，并查集就是一种用来处理多个不相交集合的合并及查询问题的数据结构。 2 算法原理 并查集是一种不相交集合的数据结构，设有一个动态集合S={s1，s2，s3，…..sn}，每个集合通过一个代表来标识，代表就是动态集S中的某个元素。 2.1 并查集的基本储存结构 我们使用树来表示并查集，我们的操作基于一个int set[]数组来实现，其中，set[i]表示i节点的父节点，也就是说set[i]和i之间是具有相互连通的关系，当我们需要了解两个节点之间是否就有连通性的时候，我们只需要判断两个节点的父节点是否相同即可。 2.2 并查集的初始化 并查集的重要思想在于，用集合中的一个元素代表集合。一开始，每个集合只有一个元素，它们的代表自然就是自己。 2.3 并查集查询根节点 按照我们刚刚的思路，要找到一个元素的代表代表，也就是要找到这棵树的根节点，我们只需要从这个元素开始一直向父亲节点迈进，直到找到一个元素的父亲节点是他本身就可以了，所以我们可以通过迭代实现： 2.3 并查集合并集合树 合并的思想也很简单，对于两个点x和 y ，先找到 x 和 y 所在并查集的根节点 x_r 和 y_r，然后进行如下判断。如果 x_r == y_r，就说明他们本身就在一个并查集，也就是同一棵树下，所以不需要再合并了；反之则将 x_r 指向 y_r，即把 x_r 的父节点设置为 y_r。代码实现也很简单： 2.4 并查集压缩路径 上面程序代码find方法只是简单地把待查找的元素所在的根返回。路径压缩是指，在find操作进行时，使find查找路径中的顶点(的父亲)都直接指向为根节点。修改后的Find代码如下： 2.5 算法的正确性、时间和空间复杂性分析 当同时使用路径压缩和按秩合并的时候。可以确保每个操作分摊下来的时间是O(α(n))，这是最优的， 这个α(n)是 inverse Ackermann function(逆阿克曼函数),当我们现在宇宙中的任何n值，可以得知α(n)&lt;5，所以并查集运算基本恒定。 因为并查集使用int set[]数组实现，因此空间复杂度为O(n)。 3 实验 3.1 实验题目 641****、并查集-臭虫也疯狂 (10分) C时间限制：1000 毫秒 | C内存限制：3000 Kb 题目内容： 霍普教授研究臭虫的性取向。实验前他弄清楚了n个臭虫的性别，并在臭虫的背上标了数字编号（1~n）。现在给一批臭虫的编号 配对，要检查里面有没有同性恋。 输入描述： 第一行是整数c,下面接着有c个测试用例。 每个测试用例的第一行是臭虫的数目n（12000），以及配对的数目m（110^6）。接下来的行就是m个配对的臭虫编号. 输出描述： 一共c行， 每行打印“testcase i:没有发现同性恋”,或者“testcase i:发现同性恋” 输入样例： 2 3 3 1 2 2 3 1 3 4 2 1 2 3 4 输出样例： testcase 1:发现同性恋 testcase 2:没有发现同性恋 3.2 问题分析 这是一道典型的并查集问题。对于一对配对的臭虫，如果它们不在一个集合，说明它们还没有关系，所以到目前为止是无法断定这个关系是否是错误的，所以认为这个关系正确，将它们合并。而如果它们已经在一个集合了，则要判断它们的性别是否相同，这里就要引入一个deep数组来表示它们的性别。 这里令0表示雄性，1表示雌性。给每一个臭虫初始化deep为0，即均为雄性或雌性。现在解释一下deep如何表示性别的相对关系： 假设A匹配B，可令deep[A]=0，deep[B]=1。现在又有B与C匹配，那么deep[B]=1,deep[C]应该为0才对。这样的话，我们可以将具有关系的臭虫并在同一集合中，并用对2取模的方式来循环表示bug之间的相对性别关系。 3.3 核心算法描述 假设A与B匹配，这里就有两种情况了。 1）A与B已经有了关系，即在同一个关系集合中，分两种情况讨论： 11）若A的深度deep与B的深度不同（即一个为0，一个为1），则说明不是同性恋，继续输入关系。 12）若A的深度deep与B的深度相同（即均为0或均为1），则说明是相同性别，为同性恋关系，已可判定结果，后续只需输入关系即可，无需继续判定。 2）A与B还没有关系，即不再同一关系集合中： 由于A与B还没有关系，所以到目前为止是无法断定这个关系是错误的，所以认为这个关系正确。那么接下来的问题就是：如何将这两个关系和并成一个关系，并且臭虫之间的相对性别关系在合并后仍然正确？分析如下： 假设A 与 B 匹配，A在以X为父节点的关系中，B在以Y为父节点的关系中。我们可以推到如下： deep[A]=a(A与父节点X的相对性别关系为a），由于B与A匹配，那么若将B并在以X为父节点的关系中，则deep[B]=(deep[A]+1)%2。而B在以Y为父节点的关系中的深度为b（即B相对Y的性别关系为b,同样Y相对B的性别关系也为b)。这样若将B并在X关系中，那么deep[Y]= ((dee[A]+1)%2+deep[b])%2；这样以后，将Y指向X。我们可以验证一下这样以后是否B与A的相别是相反的即deep[B]=(deep[A]+1)%2。 上述操作以后： deep[B]=(deep[b]+deep[Y])%2 deep[Y]= ((dee[A]+1)%2+deep[b])%2 带入后可得deep[B]=(deep[A]+1)%2即关系正确。 3.2 测试数据 因在发现同性恋后会直接中止程序，所以测试没有同性恋的情况。 一共给出了六组测试数据： （1）n=1000000,m=0（2）n=1000000,m=1000000 （1）n=10000000,m=0（2）n=1000000,m=10000000 （1）n=100000000,m=0（2）n=1000000,m=100000000 3.3 算法运行结果 表1 算法运行的时间和空间占用记录 n=1000000 n=10000000 n=100000000 m = 0 15 93 1032 m = n 31 359 3450 从结果可以明显看出，算法运行的时间随数据的增加线性增加，由此可以看出该算法的优越性。 4 讨论与总结 并查集被很多OIer认为是最简洁而优雅的数据结构之一，它拥有优越的时空复杂性。 并查集主要用于解决一些元素分组的问题。它管理一系列不相交的集合，凡是涉及到元素的分组管理问题，都可以考虑使用并查集进行维护。 5 参考文献 附录：并查集完整代码 "},{"title":"Hello World","date":"2021-09-17T13:39:19.475Z","url":"/2021/09/17/hello-world/","categories":[["undefined",""]],"content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post More info: Writing Run server More info: Server Generate static files More info: Generating Deploy to remote sites More info: Deployment"}]